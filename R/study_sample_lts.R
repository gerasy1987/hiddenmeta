#' Draw respondent-driven sample (RDS) sample from single study using data.table
#'
#' Sampling handler for drawing RDS sample with given characteristics from individual study population
#'
#' @param data pass-through population data frame.
#' @param sample_label character string that is used as prefix for all variables generated by RDS sampling (sample identifier, recruiter ID, wave, time of show-up).
#' @param hidden_var character string specifying hidden variable name (associated probability of visibility should be named \code{p_visible_[hidden_var]}).
#' @param sampling_frame character string indicating either \code{"all"} or name of variable to use for sampling if non-hidden group members are allowed. Default is the same as \code{hidden_var} for hidden group only sampling.
#' @param n_coupons number of unique coupons given to each study participant. Defaults to \code{3}. If \code{n_coupons == Inf}, all links are traced and total number of available coupons is assumed to be equal to maximum degree in population.
#' @param target_type one of \code{"sample"} or \code{"waves"}. If \code{"sample"} RDS sampling proceeds until either sample size of \code{target_n_rds} is reached or all available links are depleted. If \code{"waves"} in addition number of waves is restricted to be \code{n_waves}.
#' @param target_n_rds integer vector giving target sample size(s). If \code{length(target_n_rds) > 1}, it is assumed that more than one RDS sample is requested for link-tracing.
#' @param n_seed integer vector giving number(s) of seeds to start sampling from. If \code{length(n_seed) > 1}, it is assumed that more than one RDS sample is requested for link-tracing. Has to match length of \code{target_n_rds}.
#' @param n_waves integer vector giving number(s) of waves allowed. Defaults to \code{NULL}
#' @param add_seeds numeric indicating how many seeds to add at a time if target sample size is not reached with initial seeds. Additional seeds are randomly drawn from non-sampled hidden population members. Defaults to \code{NULL} that does not allow adding seeds.
#' @param arrival_rate numeric rate of respondent arrival per interval of time (e.g. per hour or day). Defaults to \code{5}.
#' @param drop_nonsampled logical indicating whether to drop units that are not sampled. Defaults to \code{FALSE}.
#'
#' @return Population or sample data frame for single study with RDS sample characteristics added
#'  \describe{
#'   \item{[sample_label]}{Sampling indicator}
#'   \item{[sample_label]_from}{ID of respondent who enrolled current respondent}
#'   \item{[sample_label]_t}{Time at which respondent was enrolled}
#'   \item{[sample_label]_wave}{Number of steps respondent is away from the seed (seeds are wave 0)}
#'   \item{[sample_label]_own_coupon}{ID of the coupon with which respondent was enrolled}
#'   \item{[sample_label]_coupon_[1-9]}{IDs of the coupons that were given to respondent for enrollment from their network}
#'  }
#' @export
#'
#'
#' @import data.table
#' @importFrom magrittr `%>%` `%$%`
#' @importFrom stats rpois
sample_lts <-
  function(data,
           sample_label = "lts",
           hidden_var,
           sampling_frame = hidden_var,
           n_coupons,
           target_type = c("sample", "waves"),
           target_n_rds,
           n_seed,
           n_waves = NULL,
           add_seeds = NULL,
           arrival_rate = 5,
           drop_nonsampled = FALSE) {

    target_type <- match.arg(target_type)

    .data <- data.table::copy(data)

    # remove ::: later
    .data[, links_list := retrieve_adjlist(links)]

    if (sampling_frame != hidden_var) {
      hidden_old <- .data[, paste0(c("p_visible_", ""), ..hidden_var)]
      .data[
        , (paste0("p_visible_", hidden_var)) :=
          data.table::fifelse(get(hidden_var) == 1,
                              get(paste0("p_visible_", hidden_var)),
                              1)]
      if (sampling_frame == "all") {
        .data[,hidden_var] <- 1
      } else if (is.character(sampling_frame) & length(sampling_frame == 1))
        .data[,hidden_var] <- .data[,sampling_frame]
      else
        stop("Sasmpling frame indicator is incorrectly specified in \"sampling_frame\" argument")
    }

    if (length(n_seed) != length(target_n_rds))
      stop("Number of requested samples (\"target_n_rds\") does not match number of requested
           seeds (\"n_seed\").")

    if (length(n_waves) == 1 & length(target_n_rds) > 1)
      n_waves <- rep(n_waves, times = length(target_n_rds))

    # multiple lts samples for link-tracing
    for (i in seq_along(target_n_rds)) {

      .arrival_time <-
        do.call(c, mapply(
          FUN = rep,
          x = 1:ceiling(2 * target_n_rds[i] / arrival_rate),
          times = stats::rpois(n = ceiling(2 * target_n_rds[i] / arrival_rate),
                               lambda = arrival_rate)))[
                                 1:nrow(.data[get(hidden_var) == 1])]

      if (nrow(.data[get(hidden_var) == 1]) <= n_seed[i]) {
        .seeds <- .data[get(hidden_var) == 1][["name"]]
      } else {
        .seeds <-
          sample(
            # sample out of all people in hidden population
            x = .data[get(hidden_var) == 1][["name"]],
            # select only prescribed number of subjects
            size = n_seed[i],
            prob = .data[get(hidden_var) == 1][[paste0("p_visible_", hidden_var)]],
            replace = FALSE)
      }

      if (is.infinite(n_coupons)) n_coupons <- max(sapply(.data$links_list, length))

      # at t=1 only seeds are sampled
      .sampled <-
        data.table::data.table(
          name = .seeds,
          from = -999,
          t = .arrival_time[1:length(.seeds)],
          wave = 1)[
            , (hidden_var) := .data[name %in% .seeds][[hidden_var]]
          ][
            , own_coupon := .I
          ][
            , paste0("coupon_", 1:n_coupons) :=
              lapply(1:n_coupons, function(x) paste0(own_coupon, "-", x))
          ]


      # n_coupons of their links (not just in hidden pop) are eligible
      .eligible <-
        data.table::rbindlist(
          # sample from each seed links
          lapply(
            .seeds,
            function(x){

              # presume that only hidden population links can be sampled
              .available_links <-
                .data[
                  name %in% .data[name == x, links_list][[1]] &
                    (get(hidden_var) == 1)
                ][["name"]]
              # remove ::: later
              get_new_eligible(sampled_df = .sampled,
                                            to = .available_links,
                                            parent = x,
                                            coup = n_coupons)
            }
          )
        )

      # join in eligible showup rates
      .eligible <-
        .eligible[
          , c(lapply(.SD, function(x) x[sample(.N)[1]]), list(w = .N))
          , by = to
        ][
          .data[, c("name", paste0(c("p_visible_", ""), ..hidden_var))]
          , on = .(to = name),
          paste0(c("p_visible_", ""), hidden_var) :=
            mget(paste0("i.", paste0(c("p_visible_", ""), ..hidden_var)))
        ][
          # drop those who won't show up and those who were already sampled
          # also record wave - number of links from seed
          # Q: do we exclude non-members of hidden population?
          , `:=`(
            showup = rbinom(n = .N,size = 1,
                            prob = 1 - (1 - get(paste0("p_visible_", ..hidden_var)))^w ),
            wave = 2,
            w = w/sum(w))
        ][
          showup == 1 & !(to %in% .sampled$name),
          c("from", "to", "wave", ..hidden_var, "own_coupon", "w")
        ]



      # Next, run the loop with the same procedure
      .t <- (length(.seeds) + 1)

      repeat {

        # if ran out of links add seeds at random from those not sampled
        # this also allows for adding links if initial seeds have no connections
        if (nrow(.eligible) == 0) {
          if (is.numeric(add_seeds)) {

            # get nodes that were not sampled yet
            .nonsampled <-
              setdiff(.data[get(hidden_var) == 1][["name"]], .sampled$name)

            if (length(.nonsampled) == 0) break
            else {

              # check whether we have enough remaining seeds
              # to sample according to add_seeds
              .new_seeds <- min(length(.nonsampled), add_seeds)

              # sample new seeds according to number of additional seeds specified
              .new_seeds <-
                sample(
                  x = .nonsampled,
                  size = .new_seeds,
                  prob =
                    .data[name %in% .nonsampled][[paste0("p_visible_", hidden_var)]],
                  replace = FALSE)

              .eligible <-
                data.table::as.data.table(
                  `names<-`(
                    list(
                      -999,
                      .new_seeds,
                      1,
                      .data[name %in% .new_seeds,][[hidden_var]],
                      as.character((n_seed[i] + 1):(n_seed[i] + length(.new_seeds))),
                      w = 1/.N
                    ),
                    c("from", "to", "wave", hidden_var, "own_coupon", "w")))

              # update number of seeds
              n_seed[i] <- n_seed[i] + length(.new_seeds)
            }
          } else break
        }

        # # if ran out of links and waves are target - break
        # if (target_type == "waves" & (nrow(.eligible) == 0)) break
        #
        # sample 1 individual weighting by wave
        # (so that earlier waves are more likely to be sampled)
        .new <- .eligible[sample(1:.N, size = 1, replace = FALSE, prob = w)]

        # move new sampled from eligible to sampled
        .sampled <-
          rbind(
            .sampled,
            data.table::data.table(
              name = .new$to,
              from = .new$from,
              t = .arrival_time[.t],
              wave = .new$wave,
              own_coupon = .new$own_coupon)[
                , (hidden_var) := .new[[hidden_var]]
              ][
                , paste0("coupon_", 1:n_coupons) :=
                  lapply(1:n_coupons, function(x) paste0(.new$own_coupon, "-", x))
              ])

        .eligible <- .eligible[to != .new$to]

        if ((target_type == "waves") &
            ifelse(is.null(n_waves), FALSE, (.new$wave == n_waves[i]))) {
          .available_links <- c()
        } else {
          .available_links <-
            .data[name %in% .data[name == .new$to][["links_list"]][[1]] &
                    get(hidden_var) == 1][["name"]]
        }

        # add new eligible links using the same procedure as above
        .eligible <-
          rbind(
            .eligible,
            get_new_eligible(
              sampled_df = .sampled,
              to = .available_links,
              parent = .new$to,
              coup = n_coupons)[
                , c(lapply(.SD, function(x) x[sample(.N)[1]]), list(w = .N))
                , by = to
              ][
                .data[, c("name", paste0(c("p_visible_", ""), ..hidden_var))]
                , on = .(to = name),
                paste0(c("p_visible_", ""), hidden_var) :=
                  mget(paste0("i.", paste0(c("p_visible_", ""), ..hidden_var)))
              ][
                , `:=`(
                  showup = rbinom(n = .N, size = 1,
                                  prob = 1 - (1 - get(paste0("p_visible_", ..hidden_var)))^w ),
                  wave = .new$wave + 1,
                  w = w/sum(w))
              ][ # drop those who won't show up and those who were already samples
                showup == 1 & !(to %in% .sampled$name),
                c("from", "to", "wave", ..hidden_var, "own_coupon", "w")]
          )

        # break if reached desired sample size (for waves or sample target)
        if (nrow(.sampled) >= target_n_rds[i]) break

        .t <- .t + 1

      }

      if (length(target_n_rds) == 1)
        sample_label_temp <- sample_label
      else
        sample_label_temp <- paste0(sample_label, i)

      data.table::setnames(
        .sampled,
        old = names(.sampled)[-1],
        new = paste0(sample_label_temp, "_", names(.sampled)[-1]))

      .data[
        , (sample_label_temp) := as.integer(name %in% .sampled$name)
      ][
        .sampled, on = .(name),
        names(.sampled)[-which(names(.sampled) == "name")] :=
          mget(paste0("i.", names(.sampled)[-which(names(.sampled) == "name")]))
      ]

    }

    .data[, links_list := NULL]

    # restore hidden variable
    if (sampling_frame != hidden_var)
      .data <- .data[, paste0(c("p_visible_", ""), hidden_var) := hidden_old]

    if (drop_nonsampled & length(target_n_rds) == 1) {
      .data <- .data[get(sample_label) == 1]
    } else if (drop_nonsampled) {
      .data <-
        .data[apply(.data[, paste0(sample_label, 1:length(target_n_rds)), with = FALSE],
                    1, function(x) any(x == 1))]
    }


    return(.data)

  }

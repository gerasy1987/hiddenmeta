#' Draw population(s) with given network structure for multiple studies
#'
#' Handler for drawing populations with given characteristics for multiple studies. The population characteristics can vary across studies
#'
#' @param study_designs named list of arguments to \code{get_study_population()} for each study.
#'
#' @return Meta tibble data frame with columns
#' \itemize{
#'  \item{"study"}{Character study identifier}
#'  \item{"population"}{List of tibble data frames with whole population information}
#' }
#'
#' @export
#'
#' @import data.table
get_multi_populations <- function(study_designs) {

  .pops_args <-
    sapply(study_designs, function(x) x$pop, simplify = FALSE)

  return(
    data.table::data.table(
      study = names(.pops_args),
      population =
        lapply(X = names(.pops_args),
               FUN = function(x) { apply_args(study = x, args = .pops_args[[x]]) }))
  )

}



#' Draw samples from multiple study populations according to proposed strategies
#'
#' Handler for drawing sample(s) with given characteristics from multiple study populations. The sampling characteristics can vary across and within studies
#'
#' @param data pass-through populations data frame
#' @param study_designs named list of arguments to sampling strategies used in each study.
#'
#' @return Meta tibble data frame with columns
#' \itemize{
#'  \item{"study"}{Character. Study identifier}
#'  \item{"sample"}{Character. Sampling strategy identifier (possible multiple per study}
#'  \item{"population"}{List of tibble data frames. For each combination of study and sampling strategy the data frame includes full population information and respective sampling strategy information}
#' }
#'
#' @export
#'
get_multi_samples <- function(data, study_designs) {

  if (any(sort(names(study_designs)) != sort(data$study)))
    stop("There is a mismatch in studies contained in population data and \"study_design\".")

  for (st in names(study_designs)) {
    for (samp in names(study_designs[[st]][["samples"]])) {
      data[study == st][["population"]][[1]] <-
        apply_args(study = st,
                   df = data[study == st][["population"]][[1]],
                   args = study_designs[[st]][["samples"]][[samp]])
    }
  }

  return(data)

}


#' Calculate estimands from multiple study populations
#'
#' Handler for calculating estimand(s) from multiple study populations
#'
#' @param data pass-through populations data frame
#' @param study_designs named list of arguments for inquiries used in each study
#'
#' @return Data frame with estimands and estimand labels
#'
#' @import data.table
#'
#' @export
get_multi_estimands <- function(data, study_designs) {

  # if (is.null(data$study) | is.null(data$sample)) stop("Data does not contain study or population variables, probably because it was not generated by get_multi_samples()")

  return(
    mapply(
      FUN = function(x, y) {
        .out <- apply_args(study = x,
                           args = study_designs[[x]][["inquiries"]],
                           df = y)

        .out$inquiry <- paste0(x, "_", .out$inquiry)
        .out
      },
      data$study,
      data$population,
      SIMPLIFY = FALSE) |>
      ( \(.) do.call(rbind, args = c(., make.row.names = FALSE)) )()
  )

}

#' Calculate estimators from multiple study samples
#'
#' Handler for calculating estimator(s) from multiple study samples
#'
#' @param data pass-through populations data frame
#' @param study_designs named list of arguments for inquiries used in each study
#'
#' @return Data frame with estimands and estimand labels
#'
#' @export
#'
#' @import tidyselect
#' @importFrom magrittr `%>%` `%$%`
#' @importFrom dplyr mutate filter select group_by ungroup summarize pull arrange rename_with left_join bind_rows if_all
get_multi_estimates <- function(data, study_designs) {

  .est_out <-
    data.frame(estimator = character(0),
               estimate = numeric(0),
               se = numeric(0),
               inquiry = character(0))

  # Loop over study_designs
  for (st in names(study_designs)) {
    for (samp in names(study_designs[[st]][["samples"]])) {
      for (est in names(study_designs[[st]][["estimators"]][[samp]])) {

        .new_est_out <-
          apply_args(
            study = st,
            df = data[study == st][["population"]][[1]],
            args = study_designs[[st]][["estimators"]][[samp]][[est]])

        .new_est_out$inquiry <- paste0(st, "_", .new_est_out$inquiry)
        .new_est_out$estimator <- as.character(.new_est_out$estimator)

        .est_out <- rbind(.est_out, .new_est_out, stringsAsFactors = FALSE)
      }
    }
  }

  return(.est_out)
}


#'
apply_args <- function(study, args, df = NULL) {

  .handler_pos <- which(names(args) == "handler")
  .handler_arg_pos <- which(names(args) != "handler")

  if (inherits(df, "data.frame") & length(.handler_arg_pos) != 0) {

    return(do.call(what = args[[.handler_pos]],
                   args = c(data = list(df), args[-c(.handler_pos)])))

  } else if (inherits(df, "data.frame") & length(.handler_arg_pos) == 0) {

    return(do.call(what = args[[.handler_pos]],
                   args = c(data = list(df))))

  } else if (is.null(df) & length(.handler_arg_pos) == 0) {

    stop("Either df or handler arguments have to be provided.")

  } else if (is.null(df) & length(.handler_arg_pos) != 0) {

    return(do.call(what = args[[.handler_pos]],
                   args = args[-c(.handler_pos)]))

  }

}

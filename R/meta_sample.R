#' Sample sampling-estimator strategies across studies for meta-analysis
#'
#' @param data pass-through meta population
#' @param drop_nonsampled logical indicating whether to drop units that are not sampled. Default is \code{FALSE}
#' @param sample_label character string that is used as prefix for all variables generated by TLS sampling. Default is 'meta'
#' @param selection_variables length 2 character vector of names of sample and estimator variables in population data frame (in this order). Default is 'sample' and 'estimator'
#' @param samples_per_study number of sampling strategies per study to draw
#' @param estimator_per_sample number of estimation strategies to draw per sampling strategy
#' @param force named list of length two giving the sample and estimator identifiers that are forced to be sampled across studies
#'
#' @return Tibble with simulated meta level population and sampling information
#'
#' @export
#'
#' @import tidyselect
#' @importFrom magrittr `%>%` `%$%` `%<>%`
#' @importFrom dplyr mutate filter select group_by ungroup summarize pull arrange
#' @importFrom purrr map2_int
get_meta_sample <-
  function(data, drop_nonsampled = FALSE,
           sample_label = "meta",
           selection_variables = c("sample", "estimator"),
           samples_per_study = 2, estimator_per_sample = 3,
           force = list(sample = "pps", estimator = "ht")

  ) {

    data <-
      data %>%
      dplyr::mutate(
        selected_sim = as.integer(sim_ID == sample(unique(sim_ID), size = 1))
      ) %>%
      dplyr::group_by(sim_ID, study) %>%
      dplyr::mutate(
        selected_samples =
          list(c(force$sample,
                 base::sample(x = base::setdiff(unique(do.call("c", sample)), force$sample),
                              size = min(length(unique(do.call("c", sample))) - length(force$sample),
                                         samples_per_study - length(force$sample))))),
        selected_sample =
          purrr::map2_int(sample, selected_samples, ~ as.integer(all(.x %in% .y)))
      ) %>%
      dplyr::group_by(sample, .add = TRUE) %>%
      dplyr::mutate(
        selected_estimators =
          list(c(force$estimator,
                 base::sample(x = unique(estimator),
                              size = min(length(unique(estimator)),
                                         estimator_per_sample - 1)))),
        selected_estimator =
          purrr::map2_int(estimator, selected_estimators, ~ as.integer(all(.x %in% .y)))
      ) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        !!sample_label :=
          as.integer(selected_sample == 1 & selected_estimator == 1 & selected_sim == 1)
      ) %>%
      dplyr::select(sim_ID, study, inquiry, sample, estimator, estimand, estimate, se,
                    all_of(sample_label), everything(), -starts_with("selected_"))

    if (drop_nonsampled) {
      data <-
        data %>%
        dplyr::filter(dplyr::if_any(sample_label, ~ . == 1))
    }

    return(data.frame(data, stringsAsFactors = FALSE))

  }

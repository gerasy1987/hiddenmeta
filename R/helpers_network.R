## Network simulation helpers

#' Generate a trait-based random network in smaller chunks and merge them together
#'
#' This function generates a trait-based random network with a large number of nodes in smaller chunks and merges them together. This approach helps to avoid memory issues that may arise when generating the network in a single call to \code{igraph::sample_pref()}. The resulting network should have the same properties as the one generated by a single call to \code{igraph::sample_pref()}.
#'
#' @param N number of nodes in the network.
#' @param K number of groups (traits) in the network.
#' @param prev_K named vector of prevalences with unique names identifying each group. The last element should correspond to the hidden group prevalence.
#' @param rho_K numeric vector of correlations in group memberships.
#' @param p_edge_within named list of numeric vectors giving probability of link between in-group members and out-group members for each of groups. The order of objects in list have to follow the order of `prev_K`.
#' @param p_edge_between named list of numeric values giving probability of link between in- and out-group member for each of groups. The order of objects in list have to follow the order of \code{prev_K}.
#' @param directed logical scalar indicating whether the network is directed (default is \code{FALSE}).
#' @param chunk_size size of each chunk used to generate the network (default is 1000).
#'
#' @return An igraph object representing the trait-based random network.
#'
#' @examples
#' \dontrun{# Generate a trait-based random network with 50,000 nodes
#' g <- sim_block_network(N = 50000, K = 2, prev_K = c(known1 = .2, hidden = .16), rho_K = 0.25, p_edge_within = list(known1 = c(.2, .2), hidden = c(.2, .3)), p_edge_between = list(known1 = .2, hidden = .2), directed = FALSE, chunk_size = 1000)}
#'
#' @importFrom magrittr `%>%`
#' @importFrom igraph graph_from_data_frame vertex_attr sample_pref
#' @importFrom data.table setnames rbindlist
#' @importFrom plyr mapvalues
#'
#' @export
sim_block_network <-
  function(N,
           K,
           prev_K,
           rho_K,
           p_edge_within,
           p_edge_between,
           directed = FALSE,
           chunk_size = 1000) {

    if (is.null(names(prev_K)) | length(unique(names(prev_K))) != K)
      stop("prev_K have to be named vector of prevalences with unique names identifying each group. The last element have to correspond to hidden group prevalence")

    type_names <- gen_group_types(K = K)

    # g <- igraph::make_empty_graph(n = N)

    edges <- list()
    vertex_attrs <- list()
    pos <- seq(1, N, by = chunk_size)

    for (i in seq_along(pos)) {
      start_node <- pos[i]
      end_node <- min(pos[i] + chunk_size - 1, N)

      subgraph <-
        igraph::sample_pref(nodes = end_node - start_node + 1, types = 2^K,
                            type.dist = gen_group_sizes(N = end_node - start_node + 1,
                                                        prev_K = prev_K, rho_K = rho_K,
                                                        .ord = type_names),
                            pref.matrix = gen_block_matrix(p_edge_within = p_edge_within,
                                                           p_edge_between = p_edge_between,
                                                           .ord = type_names),
                            fixed.sizes = TRUE, directed = directed, loops = FALSE)

      igraph::vertex_attr(subgraph)$type <-
        plyr::mapvalues(x = igraph::vertex_attr(subgraph)$type,
                        from = 1:(2^K),
                        to = type_names)

      vertex_attrs[[i]] <- data.table::data.table(
        name = seq(start_node, end_node),
        type = igraph::vertex_attr(subgraph)$type
      )

      edges[[i]] <- igraph::as_data_frame(subgraph) %>%
        data.table::setnames(c("from", "to"), c("from_node", "to_node")) %>%
        transform(from_node = from_node + start_node - 1, to_node = to_node + start_node - 1)
    }

    vertex_attrs <- data.table::rbindlist(vertex_attrs)
    edges <- data.table::rbindlist(edges)

    g <- igraph::graph_from_data_frame(edges, directed = directed, vertices = vertex_attrs)

    igraph::vertex_attr(g)$name <- as.numeric(igraph::vertex_attr(g)$name)

    return(g)
  }


#' Handler for Simulation of Network Using ERGM
#'
#' Draw a Simulation of Network Using Distribution Of An Exponential Family Random Graph Model Based on Observed Data
#'
#' @param fit object of ergm class produced by fitting model using \code{ergm} function
#' @param type_function function of igraph object \code{g} that takes existing vertex attributes and transforms them into \code{type} attribute in the binary coded format (consists of 0's and 1's only)
#'
#' @return igraph network object with vertex attribute \code{type} in the binary coded format (consists of 0's and 1's only)
#' @export
#'
#' @examples
#' \dontrun{
#' library(network)
#' library(ergm)
#'
#' data('faux.magnolia.high')
#'
#' fit <- ergm(faux.magnolia.high ~
#'               edges +
#'               gwesp(0.25,fixed=T) +
#'               nodematch("Grade") + nodematch("Sex"),
#'             control = control.ergm(MCMC.interval = 10000),
#'             verbose = F)
#'
#' sim_ergm_network(fit = fit,
#'                  type_function = function(g) {
#'                    paste0( as.integer(igraph::vertex_attr(g)$Sex == "M"),
#'                            as.integer(igraph::vertex_attr(g)$Grade == 9))})
#'
#' }
#'
#' @importFrom igraph vertex_attr
#' @importFrom magrittr `%>%` `%$%` `%<>%`
#' @importFrom stats simulate
sim_ergm_network <-
  function(fit,
           type_function) {

    if (!requireNamespace("intergraph", quietly = TRUE)) {
      stop(
        "Package \"intergraph\" must be installed to use this function.",
        call. = FALSE
      )
    }

    if (!inherits(fit, "ergm")) stop("fit should be ergm object")

    g <-
      stats::simulate(fit, nsim = 1) %>%
      intergraph::asIgraph(.)

    igraph::vertex_attr(g) %<>%
      { c(list(type = type_function(g)), .) }

    return(g)
  }

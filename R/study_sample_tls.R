#' Draw time-location (TLS) sample from single study
#'
#' Sampling handler for drawing TLS sample with given characteristics from individual study population
#'
#' @param data pass-through population data frame
#' @param sampling_variable character string that is used as prefix for all variables generated by TLS sampling. Default is 'tls'
#' @param drop_nonsampled logical indicating whether to drop units that are not sampled. Default is \code{FALSE}
#' @param hidden_var character string specifying hidden variable name (associated probability of visibility should be named \code{p_visible_[hidden_var]}). Defaults to "hidden" for the simulations
#' @param target_n_clusters target number of clusters (time-locations)
#' @param target_n_tls target number of sampled locations
#' @param cluster character string containing names of all locality names in the study population data frame
#'
#' @return Population or sample data frame for single study with TLS sample characteristics added
#'  \describe{
#'   \item{[sampling_variable]}{Sampling indicator}
#'   \item{[sampling_variable]_cluster}{Time-locations at which subject was encountered first}
#'   \item{[sampling_variable]_loc_present}{Time-locations at which subject is present}
#'   \item{[sampling_variable]_sampled_locs}{Sampled time-locations}
#'   \item{[sampling_variable]_weight}{Sampling weights}
#'  }
#'
#' @export
#'
#' @import dplyr
#' @importFrom tidyr nest
#' @importFrom purrr map_chr
#' @importFrom magrittr `%<>%`
sample_tls <-
  function(data,
           sampling_variable = "tls", drop_nonsampled = FALSE,
           hidden_var = "hidden",
           target_n_clusters = 2,
           target_n_tls = 50,
           cluster = paste0("loc_", 1:3)
  ) {

    if (length(cluster) < target_n_clusters)
      stop("Number of requested locations for TLS sample exceeds number of available locations")

    sampling_probs <-
      data %>%
      dplyr::filter(across(all_of(hidden_var), ~ . == 1)) %>%
      dplyr::summarise(dplyr::across(dplyr::all_of(cluster), mean, .names = "{.col}"))

    sampled_locs <-
      sampling_probs %>%
      t() %>%
      {
        sample(x = rownames(.), size = target_n_clusters, prob = as.vector(.))
      }

    temp_data <- data <- mutate(data, temp_id = 1:n())%>%
      dplyr::filter(if_any(.cols = all_of(sampled_locs), ~ . == 1))%>%
      dplyr::mutate(sampling_prob = 1/rowSums(dplyr::across(dplyr::all_of(col))))%>%
      dplyr::mutate(sampling_prob = sampling_prob/sum(sampling_prob, na.rm = TRUE))


    samp <- sample(1:nrow(temp_data), size = min(nrow(temp_data), target_n_tls), prob = temp_data$sampling_prob)

    temp_data %<>%
      {
        dplyr::left_join(
          .,
          dplyr::mutate(
            tidyr::nest(
              dplyr::slice(
                dplyr::bind_rows(
                  lapply(sampled_locs,
                         function(x) tibble(.[.[[x]] == 1,
                                              c("temp_id", paste0("p_visible_", hidden_var))],
                                            loc = x))
                ), samp#, weight_by = p_visible_hidden
              ), dat = -temp_id
            ), loc_present = purrr::map_chr(dat, ~paste0(.x$loc, collapse = ";"))
          ), by = "temp_id"
        )} %>%
      dplyr::select(temp_id, loc_present) %>%
      dplyr::mutate(
        sampled = as.integer(!is.na(loc_present)),
        sampled_locs = paste0(sampled_locs, collapse = ";"),
        "{ sampling_variable }_cluster" :=
          ifelse(is.na(loc_present),
                 yes = NA,
                 no = sapply(strsplit(x = loc_present, split = ";"), function(x) x[[1]][1]))) %>%
      dplyr::rename("{ sampling_variable }" := sampled,
                    "{ sampling_variable }_locs_sampled" := sampled_locs,
                    "{ sampling_variable }_loc_present" := loc_present) %>%
      dplyr::select(temp_id, all_of(sampling_variable), everything())

    data %<>%
      dplyr::left_join(., temp_data, by = "temp_id") %>%
      dplyr::select(-temp_id) %>%
      dplyr::mutate(across(all_of(sampling_variable), ~ ifelse(is.na(.), 0, .)),
                    "{ sampling_variable }_weight" := as.vector(as.matrix(.[, cluster]) %*% t(sampling_probs)))

    if (drop_nonsampled) data %<>% dplyr::filter(if_all(all_of(sampling_variable), ~ . == 1))

    return(data)

  }

#' Draw time-location (TLS) sample from single study
#'
#' Sampling handler for drawing TLS sample with given characteristics from individual study population
#'
#' @param data pass-through population data frame
#' @param sampling_variable character string that is used as prefix for all variables generated by TLS sampling. Default is 'tls'
#' @param drop_nonsampled logical indicating whether to drop units that are not sampled. Default is \code{FALSE}
#' @param hidden_var character string specifying hidden variable name (associated probability of visibility should be named \code{p_visible_[hidden_var]}). Defaults to "hidden" for the simulations
#' @param target_n_clusters target number of clusters (time-locations). Clusters are always sampled proportionally to their size in terms of number of hidden population members
#' @param target_cluster_type character string specifying the type of TLS sampling within each location. Either "prop" in which case \code{target_per_cluster} should give a share or "fixed" in which case \code{target_per_cluster} should be integer. Default is proportional sampling within clusters
#' @param target_per_cluster numeric target for within cluster. Either share for proportional sampling or integer for fixed sampling. If in any cluster fixed number of units required for sampling is larger than the number of units in cluster, the whole cluster is sampled and the warning is produced
#' @param clusters character string containing names of all locality names in the study population data frame
#'
#' @return Population or sample data frame for single study with TLS sample characteristics added
#'  \describe{
#'   \item{[sampling_variable]}{Sampling indicator}
#'   \item{[sampling_variable]_cluster}{Time-locations at which subject was encountered first}
#'   \item{[sampling_variable]_loc_present}{Sampled time-locations at which subject is present}
#'   \item{[sampling_variable]_loc_sampled}{Sampled time-locations at which subject was sampled}
#'   \item{[sampling_variable]_locs_sampled}{Sampled time-locations}
#'   \item{[sampling_variable]_weight}{Sampling weight without visibility}
#'   \item{[sampling_variable]_weight_visible}{Sampling weight with visibility}
#'  }
#'
#' @export
#'
#' @import data.table
#' @import dplyr
#' @importFrom tidyr nest
#' @importFrom purrr map_chr when
#' @importFrom magrittr `%<>%`
sample_tls_tidy <-
  function(data,
           sampling_variable = "tls", drop_nonsampled = FALSE,
           hidden_var = "hidden",
           target_n_clusters,
           target_cluster_type = c("prop", "fixed"),
           target_per_cluster,
           clusters
  ) {

    target_cluster_type <- match.arg(target_cluster_type)

    if (length(clusters) < target_n_clusters)
      stop("Number of requested locations for TLS sample exceeds number of available locations")


    if ((target_cluster_type == "prop" & (target_per_cluster > 1 | target_per_cluster < 0)) |
        (target_cluster_type == "fixed" & ((target_per_cluster %% 1) != 0))) {
      stop("There is a mismatch between type and target specified for within clusters sampling")
    }

    sampling_probs <-
      data %>%
      # think about adding visibility here as well
      purrr::when(
        !is.null(hidden_var) ~ dplyr::filter(., across(all_of(hidden_var), ~ .x == 1)),
        ~ .) %>%
      dplyr::summarise(dplyr::across(dplyr::all_of(clusters), sum, .names = "{.col}")) %>%
      { tibble(loc = colnames(.), n = unlist(.), loc_sampling_prob = unlist(.)/sum(.)) }

    sampled_locs <-
      sampling_probs %>%
      {
        sample(x = .$loc, size = target_n_clusters, prob = .$loc_sampling_prob)
      }

    if (target_cluster_type == "prop") {
      sampling_probs %<>%
        dplyr::filter(loc %in% sampled_locs) %>%
        dplyr::mutate(
          target_n = n * target_per_cluster,
          target_n =
            dplyr::if_else((target_n %% 1) <= median(target_n %% 1),
                           floor(target_n),
                           ceiling(target_n)),
          unit_sampling_prob = target_n/n
        )
    } else if (target_cluster_type == "fixed") {
      sampling_probs %<>%
        dplyr::filter(loc %in% sampled_locs) %>%
        dplyr::mutate(
          target_n = min(target_per_cluster, n),
          unit_sampling_prob = target_n/n
        )

      if (any(target_per_cluster > sampling_probs$n))
        warning("For some clusters number of units required by sampling procedure was larger than cluster size. Probability of unit sampling within those clusters is set to 1")
    }

    data %<>% dplyr::mutate(temp_id = 1:n())

    data %<>%
      dplyr::filter(if_any(.cols = all_of(sampled_locs), ~ . == 1)) %>%
      purrr::when(
        !is.null(hidden_var) ~ dplyr::filter(., if_all(all_of(hidden_var), ~ .x == 1)),
        ~ .) %>%
      {
        dplyr::bind_rows(
          lapply(sampled_locs,
                 function(x) tibble(.[.[[x]] == 1,], loc = x))
        )
      } %>%
      dplyr::left_join(., sampling_probs, by = "loc") %>%
      dplyr::group_by(loc) %>%
      dplyr::mutate(
        sampled = sample(c(rep(1, unique(target_n)),
                           rep(0, n() - unique(target_n))),
                         prob = if (!is.null(hidden_var)) get(paste0("p_visible_", hidden_var)))
      )%>%
      dplyr::group_by(temp_id, .add = FALSE) %>%
      purrr::when(
        !is.null(hidden_var) ~ dplyr::summarise(
          .,
          sampled = as.integer(any(sampled == 1)),
          loc_present = paste0(loc, collapse = ";"),
          loc_sampled = dplyr::if_else(any(sampled == 1),
                                       paste0(loc[which(sampled == 1)], collapse = ";"),
                                       NA_character_),
          weight = 1/(1 - prod(c(1 - unit_sampling_prob))),
          weight_visible = 1/(1 - prod(1 - get(paste0("p_visible_", hidden_var)) * unit_sampling_prob))
        ),
        ~ dplyr::summarise(
          .,
          sampled = as.integer(any(sampled == 1)),
          loc_present = paste0(loc, collapse = ";"),
          loc_sampled = dplyr::if_else(any(sampled == 1),
                                       paste0(loc[which(sampled == 1)], collapse = ";"),
                                       NA_character_),
          weight = 1/(1 - prod(c(1 - unit_sampling_prob))),
          weight_visible = 1/(1 - prod(1 - unit_sampling_prob))
      )) %>%
      dplyr::ungroup() %>%
      dplyr::filter(sampled == 1) %>%
      dplyr::select(-sampled) %>%
      dplyr::mutate(
        locs_sampled = paste0(na.omit(unique(loc_sampled)), collapse = ";")
      ) %>%
      dplyr::rename_with(~ paste0(sampling_variable, "_", .), .cols = -temp_id) %>%
      {
        left_join(
          dplyr::mutate(data, "{ sampling_variable }" := as.integer(temp_id %in% .$temp_id)),
          .,
          by = "temp_id"
        )
      } %>%
      dplyr::select(-temp_id)

    if (drop_nonsampled) data %<>% dplyr::filter(if_all(all_of(sampling_variable), ~ . == 1))

    return(data)

  }


#' Draw time-location (TLS) sample from single study
#'
#' Sampling handler for drawing TLS sample with given characteristics from individual study population
#'
#' @param data pass-through population data frame
#' @param sampling_variable character string that is used as prefix for all variables generated by TLS sampling. Default is 'tls'
#' @param drop_nonsampled logical indicating whether to drop units that are not sampled. Default is \code{FALSE}
#' @param hidden_var character string specifying hidden variable name (associated probability of visibility should be named \code{p_visible_[hidden_var]}). Defaults to "hidden" for the simulations
#' @param target_n_clusters target number of clusters (time-locations). Clusters are always sampled proportionally to their size in terms of number of hidden population members
#' @param target_cluster_type character string specifying the type of TLS sampling within each location. Either "prop" in which case \code{target_per_cluster} should give a share or "fixed" in which case \code{target_per_cluster} should be integer. Default is proportional sampling within clusters
#' @param target_per_cluster numeric target for within cluster. Either share for proportional sampling or integer for fixed sampling. If in any cluster fixed number of units required for sampling is larger than the number of units in cluster, the whole cluster is sampled and the warning is produced
#' @param clusters character string containing names of all locality names in the study population data frame
#'
#' @return Population or sample data frame for single study with TLS sample characteristics added
#'  \describe{
#'   \item{[sampling_variable]}{Sampling indicator}
#'   \item{[sampling_variable]_cluster}{Time-locations at which subject was encountered first}
#'   \item{[sampling_variable]_loc_present}{Sampled time-locations at which subject is present}
#'   \item{[sampling_variable]_loc_sampled}{Sampled time-locations at which subject was sampled}
#'   \item{[sampling_variable]_locs_sampled}{Sampled time-locations}
#'   \item{[sampling_variable]_weight}{Sampling weight without visibility}
#'   \item{[sampling_variable]_weight_visible}{Sampling weight with visibility}
#'  }
#'
#' @export
#'
#' @import data.table
#' @import dplyr

sample_tls <-
  function(data,
           sampling_variable = "tls", drop_nonsampled = FALSE,
           hidden_var = "hidden",
           target_n_clusters,
           target_cluster_type = c("prop", "fixed"),
           target_per_cluster,
           clusters
  ) {

    target_cluster_type <- match.arg(target_cluster_type)

    if (length(clusters) < target_n_clusters)
      stop("Number of requested locations for TLS sample exceeds number of available locations")


    if ((target_cluster_type == "prop" & (target_per_cluster > 1 | target_per_cluster < 0)) |
        (target_cluster_type == "fixed" & ((target_per_cluster %% 1) != 0))) {
      stop("There is a mismatch between type and target specified for within clusters sampling")
    }

    #get sampling probabilities for locations
    data.table::setDT(data)
    if(!is.null(hidden_var)){
      sampling_probs <- data[data[[eval(hidden_var)]] == 1][,lapply(.SD, sum),.SDcols = clusters]
    } else {
      sampling_probs <- data[,lapply(.SD,sum),.SDcols = clusters]
    }

    sampling_probs <- sampling_probs %>%
      data.table::melt.data.table(variable.name = "loc", value.name = "n", id.vars = NULL, measure.vars = colnames(.)) %>%
      .[, loc_sampling_prob := n/sum(n)]

    #sample locations
    sampled_locs <- sample(x = sampling_probs[,loc],
                           size = target_n_clusters,
                           prob = sampling_probs[,loc_sampling_prob])


    if(target_cluster_type == "prop") {
      sampling_probs <- sampling_probs[loc %in% sampled_locs][,target_n := n * target_per_cluster] %>%
        .[,target_n := data.table::fifelse((target_n %% 1) <= median(target_n %% 1),
                                           floor(target_n),
                                           ceiling(target_n))] %>%
        .[,unit_sampling_prob := target_n/n]
    } else if (target_cluster_type == "fixed") {
      sampling_probs <- sampling_probs[loc %in% sampled_locs][,target_n := min(target_per_cluster,n)] %>%
        .[,unit_sampling_prob := target_n/n]

      if (any(target_per_cluster > sampling_probs[,n])) {
        warning("For some clusters number of units required by sampling procedure was larger than cluster size. Probability of unit sampling within those clusters is set to 1")
      }
    }

    #select sampled units that are hidden
    data[, temp_id := .I]
    data_orig <- copy(data)
    data <- data[data[, Reduce(`|`, lapply(.SD, `==`, 1)), .SDcols = as.character(sampled_locs)],]

    if(!is.null(hidden_var)) {
      data <- data[data[[eval(hidden_var)]] == 1]
    }

    #make units that are sampled in multiple locs separate observations
    data <- data %>%
      {
        data.table::rbindlist(
          lapply(as.character(sampled_locs),
               function(x) {
                 .[.[[eval(x)]] == 1][,loc := x]
               })
          )
      } %>%
      #add sampling probabilies
      sampling_probs[., on = "loc"]

    #add binary indicator for sampled units
    data[, sampled := sample(c(rep(1, unique(target_n)), rep(0, .N - unique(target_n))),
                                     prob = if (!is.null(hidden_var)) get(paste0("p_visible_", hidden_var))),
         by = loc]

    #add tls variables
    data[, c("sampled", "loc_present", "loc_sampled", "weight", "weight_visible") := list(
      as.integer(any(sampled == 1)),
      paste(loc, collapse = ";"),
      ifelse(any(sampled == 1), paste(loc[sampled == 1], collapse = ";"), NA_character_),
      1 / (1 - prod(1 - unit_sampling_prob)),
      if (!is.null(hidden_var)) {
        1 / (1 - prod(1 - get(paste0("p_visible_", hidden_var)) * unit_sampling_prob))
      } else {
        1 / (1 - prod(1 - unit_sampling_prob))
      }
    ), by = temp_id]

    #select sampled units
    data <- data[sampled == 1, c("temp_id","loc_present","loc_sampled","weight","weight_visible"), with = FALSE][]
    #remove duplicated observations (grouping in data.table does not reduce rows automatically)
    data <- data[!duplicated(data[,temp_id]),]
    #set tls colnames
    data <- data.table::setnames(data, c("temp_id", paste0(sampling_variable, "_", names(data)[-which(names(data) == "temp_id")])))
    #add binary indicator for tls membership
    data_orig[, c(sampling_variable) := as.integer(temp_id %in% data[["temp_id"]]), by = temp_id]
    #merge on temp_id
    data <- data[data_orig, on = "temp_id"]
    data[, temp_id := NULL]

    if (drop_nonsampled) {
      data <- data[data[[eval(sampling_variable)]] == 1]
    }

    return(data)

  }

#' Draw respondent-driven sample (RDS) sample from single study using data.table
#'
#' Sampling handler for drawing RDS sample with given characteristics from individual study population
#'
#' @param data pass-through population data frame
#' @param sampling_variable character string that is used as prefix for all variables generated by RDS sampling (sample identifier, recruiter ID, wave, time of show-up)
#' @param hidden_var character string specifying hidden variable name (associated probability of visibility should be named \code{p_visible_[hidden_var]}). Defaults to "hidden" for the simulations
#' @param n_seed number of seeds randomly drawn from members of hidden population (group K)
#' @param n_coupons number of unique coupons given to each study participant
#' @param n_waves number of waves allowed. Disregarded in \code{target_type = 'sample'}
#' @param target_type one of 'sample' or 'waves'
#' @param target_n_rds numeric target size of RDS sample. If \code{target_type = "sample"}, this gives maximum number of respondents to be sampled (right now the RDS network can also end before reaching sample size target). If \code{target_type = "waves"}, this gives maximum number of waves of recruitment allowed
#' @param add_seeds numeric indicating how many seeds to add at a time if target sample size is not reached with initial seeds. Additional seeds are randomly drawn from non-sampled hidden population members. Defaults to \code{NULL} that does not allow adding seeds
#' @param arrival_rate numeric rate of respondent arrival per interval of time (e.g. per hour or day). Defaults to 5
#' @param linktrace character string indicating either \code{"all"} or name of variable to use in RDS+ sample to sample from. Default is \code{NULL}
#' @param drop_nonsampled logical indicating whether to drop units that are not sampled. Default is \code{FALSE}
#'
#' @return Population or sample data frame for single study with RDS sample characteristics added
#'  \describe{
#'   \item{[sampling_variable]}{Sampling indicator}
#'   \item{[sampling_variable]_from}{ID of respondent who enrolled current respondent}
#'   \item{[sampling_variable]_t}{Time at which respondent was enrolled}
#'   \item{[sampling_variable]_wave}{Number of steps respondent is away from the seed (seeds are wave 0)}
#'   \item{[sampling_variable]_own_coupon}{ID of the coupon with which respondent was enrolled}
#'   \item{[sampling_variable]_coupon_[1-9]}{IDs of the coupons that were given to respondent for enrollment from their network}
#'  }
#' @export
#'
#' @examples
#' \dontrun{
#' sample_rds(data = get_pop_network())
#' }
#'
#' @import data.table
#' @importFrom magrittr `%>%` `%$%`
#' @importFrom stats rpois
sample_rds <-
  function(data,
           sampling_variable = "rds",
           hidden_var,
           target_type = c("sample", "waves"),
           n_seed, n_coupons, n_waves = NULL,
           target_n_rds,
           add_seeds = NULL,
           arrival_rate = 5,
           linktrace = NULL,
           drop_nonsampled = FALSE) {

    target_type <- match.arg(target_type)

    .data <- data.table::copy(data)

    .data[, links_list := retrieve_adjlist(links)]

    if (!is.null(linktrace)) {
      hidden_old <- .data[[hidden_var]]
      if (linktrace == "all")
        .data[,hidden_var] <- 1
      else if (is.character(linktrace) & length(linktrace == 1))
        .data[,hidden_var] <- .data[,linktrace]
      else
        stop("RDS+ sample indicator is incorrectly specified in linktrace argument")
    }

    .arrival_time <-
      do.call(c, mapply(FUN = rep,
                        x = 1:ceiling(2*target_n_rds/arrival_rate),
                        times = stats::rpois(n = ceiling(2*target_n_rds/arrival_rate),
                                             lambda = arrival_rate)))[
                                               1:nrow(.data[get(hidden_var) == 1])]

    if (nrow(.data[get(hidden_var) == 1,]) <= n_seed) {
      .seeds <- .data[get(hidden_var) == 1][["name"]]
    } else {
      .seeds <-
        sample(
          # sample out of all people in hidden population
          x = .data[get(hidden_var) == 1][["name"]],
          # select only prescribed number of subjects
          size = n_seed,
          prob = .data[get(hidden_var) == 1][[paste0("p_visible_", hidden_var)]],
          replace = FALSE)
    }

    # at t=1 only seeds are sampled
    .sampled <-
      data.table::data.table(
        name = .seeds,
        from = -999,
        t = .arrival_time[1:length(.seeds)],
        wave = 1)[
          , (hidden_var) := .data[name %in% .seeds][[hidden_var]]
        ][
          , own_coupon := .I
        ][
          , paste0("coupon_", 1:n_coupons) :=
            lapply(1:n_coupons, function(x) paste0(own_coupon, "-", x))
        ]


    # n_coupons of their links (not just in hidden pop) are eligible
    .eligible <-
      data.table::rbindlist(
        # sample from each seed links
        lapply(
          .seeds,
          function(x){

            # presume that only hidden population links can be sampled
            .available_links <-
              .data[
                name %in% .data[name == x, links_list][[1]] &
                  (get(hidden_var) == 1)
              ][["name"]]

            get_new_eligible(sampled_df = .sampled,
                             to = .available_links,
                             parent = x,
                             coup = n_coupons)
          }
        )
      )

    # join in eligible showup rates
    .eligible <-
      .eligible[
        .data[, c("name", paste0(c("p_visible_", ""), ..hidden_var))]
        , on = .(to = name),
        paste0(c("p_visible_", ""), hidden_var) :=
          mget(paste0("i.", paste0(c("p_visible_", ""), ..hidden_var)))
      ][
        # drop those who won't show up and those who were already sampled
        # also record wave - number of links from seed
        # Q: do we exclude non-members of hidden population?
        , `:=`(
          showup = rbinom(n = .N,size = 1,
                          prob = get(paste0("p_visible_", ..hidden_var))),
          wave = 2)
      ][
        showup == 1 & !(to %in% .sampled$name) & !duplicated(to),
        c("from", "to", "wave", ..hidden_var, "own_coupon")
      ]



    # Next, run the loop with the same procedure
    .t <- (length(.seeds) + 1)

    repeat {

      # if ran out of links add seeds at random from those not sampled
      # this also allows for adding links if initial seeds have no connections
      if (target_type == "sample" & (nrow(.eligible) == 0)) {
        if (is.numeric(add_seeds)) {

          # get nodes that were not sampled yet
          .nonsampled <-
            setdiff(.data[get(hidden_var) == 1][["name"]], .sampled$name)

          if (length(.nonsampled) == 0) break
          else {

            # check whether we have enough remaining seeds
            # to sample according to add_seeds
            .new_seeds <- min(length(.nonsampled), add_seeds)

            # sample new seeds according to number of additional seeds specified
            .new_seeds <-
              sample(
                x = .nonsampled,
                size = .new_seeds,
                prob =
                  .data[name %in% .nonsampled][[paste0("p_visible_", hidden_var)]],
                replace = FALSE)

            .eligible <-
              data.table::data.table(
                from = -999,
                to = .new_seeds,
                wave = 1,
                own_coupon = as.character((n_seed+1):(n_seed + length(.new_seeds)))
              )[
                , (hidden_var) := .data[name %in% .new_seeds,][[hidden_var]]
              ]

            # update number of seeds
            n_seed <- n_seed + length(.new_seeds)
          }
        } else break
      }

      # if ran out of links and waves are target - break
      if (target_type == "waves" & (nrow(.eligible) == 0)) break

      # sample 1 individual weighting by wave
      # (so that earlier waves are more likely to be sampled)
      .new <- .eligible[sample(1:.N, size = 1, replace = FALSE, prob = 1/wave)]

      # move new sampled from eligible to sampled
      .sampled <-
        rbind(
          .sampled,
          data.table::data.table(
            name = .new$to,
            from = .new$from,
            t = .arrival_time[.t],
            wave = .new$wave,
            own_coupon = .new$own_coupon)[
              , (hidden_var) := .new[[hidden_var]]
            ][
              , paste0("coupon_", 1:n_coupons) :=
                lapply(1:n_coupons, function(x) paste0(.new$own_coupon, "-", x))
            ])

      .eligible <- .eligible[to != .new$to]

      # presume that only hidden population links can be sampled
      if ((target_type == "waves") &
          ifelse(is.null(n_waves), FALSE, (.new$wave == n_waves))) {
        .available_links <- c()
      } else {
        .available_links <-
          .data[name %in% .data[name == .new$to][["links_list"]][[1]] &
                  get(hidden_var) == 1][["name"]]
      }

      # add new eligible links using the same procedure as above
      .eligible <-
        rbind(
          .eligible,
          get_new_eligible(
            sampled_df = .sampled,
            to = .available_links,
            parent = .new$to,
            coup = n_coupons)[
              .data[, c("name", paste0(c("p_visible_", ""), ..hidden_var))]
              , on = .(to = name),
              paste0(c("p_visible_", ""), hidden_var) :=
                mget(paste0("i.", paste0(c("p_visible_", ""), ..hidden_var)))
            ][
              , `:=`(
                showup = rbinom(n = .N, size = 1,
                                prob = get(paste0("p_visible_", ..hidden_var))),
                wave = .new$wave + 1)
            ][ # drop those who won't show up and those who were already samples
              showup == 1 & !(to %in% .sampled$name) & !duplicated(to),
              c("from", "to", "wave", ..hidden_var, "own_coupon")]
        )

      # break if reached desired sample size (for waves or sample target)
      if (nrow(.sampled) >= target_n_rds) break

      .t <- .t + 1

    }

    setnames(.sampled,
             old = names(.sampled)[-1],
             new = paste0(sampling_variable, "_", names(.sampled)[-1]))

    .data[
      , (sampling_variable) := as.integer(name %in% .sampled$name)
    ][
      .sampled, on = .(name),
      names(.sampled)[-which(names(.sampled) == "name")] :=
        mget(paste0("i.", names(.sampled)[-which(names(.sampled) == "name")]))
    ][
      , links_list := NULL
    ]

    # restore hidden variable
    if (!is.null(linktrace)) .data[,hidden_var] <- hidden_old

    if (drop_nonsampled) .data <- .data[get(sampling_variable) == 1]

    return(.data)

  }

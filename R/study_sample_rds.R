#' Draw respondent-driven sample (RDS) sample from single study
#'
#' Sampling handler for drawing RDS sample with given characteristics from individual study population
#'
#' @param data pass-through population data frame
#' @param sampling_variable character string that is used as prefix for all variables generated by RDS sampling (sample identifier, recruiter ID, wave, time of show-up)
#' @param drop_nonsampled logical indicating whether to drop units that are not sampled. Default is \code{FALSE}
#' @param n_seed number of seeds randomly drawn from members of hidden population (group K)
#' @param n_coupons number of unique coupons given to each study participant
#' @param target_type one of 'sample' or 'waves'
#' @param target_n_rds numeric target size of RDS sample. If \code{target_type = "sample"}, this gives maximum number of respondents to be sampled (right now the RDS network can also end before reaching sample size target). If \code{target_type = "waves"}, this gives maximum number of waves of recruitment allowed
#'
#' @return Population or sample data frame for single study with RDS sample characteristics added
#' @export
#'
#' @examples
#' \dontrun{
#' sample_rds(data = get_pop_network())
#' }
#'
#' @import dplyr
#' @importFrom igraph sample_pref vertex_attr as_adj as_adj_list
#' @importFrom magrittr `%>%` `%<>%`
#' @importFrom purrr when
#' @importFrom stats rbinom
sample_rds <-
  function(data, sampling_variable = "rds", drop_nonsampled = FALSE,
           n_seed = 10, n_coupons = 3, target_type = c("sample", "waves"),
           target_n_rds = 3) {

    target_type <- match.arg(target_type)

    if (length(data$name[data$hidden == 1]) <= n_seed) {
      seeds <- data$name[data$hidden == 1]
    } else {
      seeds <-
        sample(
          data$name[data$hidden == 1], # sample out of all people in hidden population
          size = n_seed, # select only prescribed number of subjects
          data$p_visible_hidden[data$hidden == 1],
          replace = FALSE)
    }

    # at t=1 only seeds are sampled
    sampled <-
      dplyr::tibble(name = seeds, from = -999, t = 1:length(seeds), wave = 1,
                    hidden = data$hidden[data$name %in% seeds], own_coupon = as.character(t))

    for (j in 1:n_coupons) {
      sampled[paste0("coupon_", j)] <- paste0(sampled$own_coupon, "-", j)
    }

    # n_coupons of their links (not just in hidden pop) are eligible
    eligible <-
      seeds %>%
      # sample from each seed links
      lapply(.,
             function(x){

               # presume that only hidden population links can be sampled
               available_links <-
                 data %>%
                 dplyr::filter(
                   name %in% unlist(data$links[data$name == x]),
                   hidden == 1
                 ) %>%
                 .$name


               if (length(available_links) > 0) {
                 if (length(available_links) == 1) {
                   dplyr::tibble(
                     from = x,
                     to = as.integer(available_links),
                     own_coupon = sample(
                       x = unname(unlist(sampled[sampled$name == x,
                                                 grep("^coupon\\_", names(sampled))])),
                       size = 1))
                 } else {
                   dplyr::tibble(
                     from = x,
                     to = sample(x = as.integer(available_links),
                                 size = min(length(available_links), n_coupons),
                                 replace = FALSE),
                     own_coupon = sample(
                       x = unname(unlist(sampled[sampled$name == x,
                                                 grep("^coupon\\_", names(sampled))])),
                       size = min(length(available_links), n_coupons)))
                 }
               }
             }) %>%
      dplyr::bind_rows() %>%
      # join in eligible showup rates
      dplyr::left_join(., data[, c("name", "p_visible_hidden", "hidden")],
                       by = c(to = "name")) %>%
      # drop those who won't show up and those who were already sampled
      # also record wave - number of links from seed
      dplyr::mutate(
        showup = rbinom(n = dplyr::n(), size = 1, prob = p_visible_hidden),
        wave = 2) %>%
      dplyr::filter(showup == 1,
                    !(to %in% sampled$name),
                    !duplicated(to)) %>%
      # do we exclude non-members of hidden population?
      # dplyr::filter(hidden == 1) %>%
      dplyr::select(from, to, wave, hidden, own_coupon)

    # Next, run the loop with the same procedure
    t <- (length(seeds) + 1)

    repeat {

      # sample 1 individual according to wave!
      new <-
        dplyr::slice_sample(eligible, n = 1, replace = FALSE, weight_by = 1/wave)

      # move sampled from eligible to sampled
      sampled <-
        dplyr::tibble(name = new$to,
                      from = new$from,
                      t = t,
                      wave = new$wave,
                      hidden = new$hidden,
                      own_coupon = unname(new$own_coupon)) %>%
        dplyr::bind_cols(.,
                         `names<-`(as.list(paste0(new$own_coupon, "-", 1:n_coupons)),
                                   paste0("coupon_", 1:n_coupons))) %>%
        dplyr::bind_rows(sampled, .)

      eligible %<>% dplyr::filter(to != new$to)

      # presume that only hidden population links can be sampled

      if ((target_type == "waves") & (new$wave == target_n_rds)) {
        new_available_links <- c()
      } else {
        new_available_links <-
          data %>%
          dplyr::filter(
            name %in% unlist(data$links[data$name == new$to]),
            hidden == 1
          ) %>%
          .$name
      }

      # add new eligible links using the same procedure as above
      if (length(new_available_links) > 0) {

        eligible <-
          new_available_links %>%
          purrr::when(
            length(new_available_links) == 1 ~
              dplyr::tibble(from = new$to,
                            to = .,
                            own_coupon = sample(
                              x = unname(unlist(sampled[sampled$name == new$to,
                                                        grep("^coupon\\_", x = names(sampled))])),
                              size = 1)),
            dplyr::tibble(from = new$to,
                          to = sample(x = as.integer(.), size = min(length(.),n_coupons),
                                      replace = FALSE),
                          own_coupon = sample(
                            x = unname(unlist(sampled[sampled$name == new$to,
                                                      grep("^coupon\\_", x = names(sampled))])),
                            size = min(length(.),n_coupons)))) %>%
          # join in eligible showup rates
          dplyr::left_join(., data[, c("name", "p_visible_hidden", "hidden")],
                           by = c(to = "name")) %>%
          # drop those who won't show up and those who were already samples
          dplyr::mutate(showup = rbinom(n = dplyr::n(), size = 1,
                                        prob = p_visible_hidden),
                        wave = new$wave + 1) %>%
          dplyr::filter(showup == 1,
                        !(to %in% sampled$name),
                        !duplicated(to)) %>%
          # do we exclude non-members of hidden population?
          # dplyr::filter(hidden == 1) %>%
          dplyr::select(from, to, wave, hidden, own_coupon) %>%
          dplyr::bind_rows(eligible, .)
      }

      if (target_type == "sample" & (nrow(sampled) == target_n_rds)) break
      if (nrow(eligible) == 0) break

      t <- t + 1
    }

    data[,sampling_variable] <- as.integer(data$name %in% sampled$name)
    names(sampled) %<>% {c(.[1], paste0(sampling_variable, "_", .[-1]))}

    data %<>% dplyr::left_join(., sampled, by = "name")

    if (drop_nonsampled) data %<>% dplyr::filter_at(dplyr::vars(sampling_variable), ~ . == 1)

    return(data)

  }
